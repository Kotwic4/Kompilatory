Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> INSTRUCTIONS
Rule 2     INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION
Rule 3     INSTRUCTIONS -> INSTRUCTION
Rule 4     INSTRUCTION -> STATEMENT ;
Rule 5     INSTRUCTION -> IF_STATEMENT
Rule 6     INSTRUCTION -> WHILE_STATEMENT
Rule 7     INSTRUCTION -> FOR_STATEMENT
Rule 8     STATEMENT -> ASSIGNMENT
Rule 9     STATEMENT -> KEYWORD
Rule 10    ASSIGNMENT -> LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION
Rule 11    LEFT_ASSIGNMENT -> ID
Rule 12    LEFT_ASSIGNMENT -> ACCESS
Rule 13    ACCESS -> ID [ SEQUENCE ]
Rule 14    SEQUENCE -> SEQUENCE , EXPRESSION
Rule 15    SEQUENCE -> EXPRESSION
Rule 16    VALUE -> FLOAT
Rule 17    VALUE -> INT
Rule 18    VALUE -> STRING
Rule 19    VALUE -> ID
Rule 20    VALUE -> MATRIX
Rule 21    VALUE -> ACCESS
Rule 22    MATRIX -> [ ROWS ]
Rule 23    ROWS -> ROWS ; SEQUENCE
Rule 24    ROWS -> SEQUENCE
Rule 25    EXPRESSION -> VALUE
Rule 26    EXPRESSION -> - EXPRESSION
Rule 27    EXPRESSION -> EXPRESSION '
Rule 28    EXPRESSION -> ( EXPRESSION )
Rule 29    EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
Rule 30    EXPRESSION -> FUNCTION ( EXPRESSION )
Rule 31    KEYWORD -> PRINT SEQUENCE
Rule 32    KEYWORD -> BREAK
Rule 33    KEYWORD -> CONTINUE
Rule 34    KEYWORD -> RETURN EXPRESSION
Rule 35    CONDITION -> EXPRESSION COMPARISION_OPERATOR EXPRESSION
Rule 36    BODY -> { INSTRUCTIONS }
Rule 37    BODY -> INSTRUCTION
Rule 38    IF_STATEMENT -> IF ( CONDITION ) BODY
Rule 39    IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY
Rule 40    WHILE_STATEMENT -> WHILE ( CONDITION ) BODY
Rule 41    FOR_STATEMENT -> FOR ID = RANGE BODY
Rule 42    RANGE -> EXPRESSION : EXPRESSION
Rule 43    RANGE -> EXPRESSION : EXPRESSION : EXPRESSION
Rule 44    ASSIGNMENT_OPERATOR -> =
Rule 45    ASSIGNMENT_OPERATOR -> PLUS_ASSIGN
Rule 46    ASSIGNMENT_OPERATOR -> MINUS_ASSIGN
Rule 47    ASSIGNMENT_OPERATOR -> TIMES_ASSIGN
Rule 48    ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN
Rule 49    COMPARISION_OPERATOR -> <
Rule 50    COMPARISION_OPERATOR -> >
Rule 51    COMPARISION_OPERATOR -> EQ
Rule 52    COMPARISION_OPERATOR -> NEQ
Rule 53    COMPARISION_OPERATOR -> GE
Rule 54    COMPARISION_OPERATOR -> LE
Rule 55    MATHEMATICAL_OPERATOR -> +
Rule 56    MATHEMATICAL_OPERATOR -> -
Rule 57    MATHEMATICAL_OPERATOR -> *
Rule 58    MATHEMATICAL_OPERATOR -> /
Rule 59    MATHEMATICAL_OPERATOR -> M_PLUS
Rule 60    MATHEMATICAL_OPERATOR -> M_MINUS
Rule 61    MATHEMATICAL_OPERATOR -> M_TIMES
Rule 62    MATHEMATICAL_OPERATOR -> M_DIVIDE
Rule 63    FUNCTION -> EYE
Rule 64    FUNCTION -> ZEROS
Rule 65    FUNCTION -> ONES

Terminals, with rules where they appear

'                    : 27
(                    : 28 30 38 39 40
)                    : 28 30 38 39 40
*                    : 57
+                    : 55
,                    : 14
-                    : 26 56
/                    : 58
:                    : 42 43 43
;                    : 4 23
<                    : 49
=                    : 41 44
>                    : 50
BREAK                : 32
CONTINUE             : 33
DIVIDE_ASSIGN        : 48
ELSE                 : 39
EQ                   : 51
EYE                  : 63
FLOAT                : 16
FOR                  : 41
GE                   : 53
ID                   : 11 13 19 41
IF                   : 38 39
INT                  : 17
LE                   : 54
MINUS_ASSIGN         : 46
M_DIVIDE             : 62
M_MINUS              : 60
M_PLUS               : 59
M_TIMES              : 61
NEQ                  : 52
ONES                 : 65
PLUS_ASSIGN          : 45
PRINT                : 31
RETURN               : 34
STRING               : 18
TIMES_ASSIGN         : 47
WHILE                : 40
ZEROS                : 64
[                    : 13 22
]                    : 13 22
error                : 
{                    : 36
}                    : 36

Nonterminals, with rules where they appear

ACCESS               : 12 21
ASSIGNMENT           : 8
ASSIGNMENT_OPERATOR  : 10
BODY                 : 38 39 39 40 41
COMPARISION_OPERATOR : 35
CONDITION            : 38 39 40
EXPRESSION           : 10 14 15 26 27 28 29 29 30 34 35 35 42 42 43 43 43
FOR_STATEMENT        : 7
FUNCTION             : 30
IF_STATEMENT         : 5
INSTRUCTION          : 2 3 37
INSTRUCTIONS         : 1 2 36
KEYWORD              : 9
LEFT_ASSIGNMENT      : 10
MATHEMATICAL_OPERATOR : 29
MATRIX               : 20
RANGE                : 41
ROWS                 : 22 23
SEQUENCE             : 13 14 23 24 31
STATEMENT            : 4
VALUE                : 25
WHILE_STATEMENT      : 6
start                : 0

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . INSTRUCTIONS
    (2) INSTRUCTIONS -> . INSTRUCTIONS INSTRUCTION
    (3) INSTRUCTIONS -> . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . IF_STATEMENT
    (6) INSTRUCTION -> . WHILE_STATEMENT
    (7) INSTRUCTION -> . FOR_STATEMENT
    (8) STATEMENT -> . ASSIGNMENT
    (9) STATEMENT -> . KEYWORD
    (38) IF_STATEMENT -> . IF ( CONDITION ) BODY
    (39) IF_STATEMENT -> . IF ( CONDITION ) BODY ELSE BODY
    (40) WHILE_STATEMENT -> . WHILE ( CONDITION ) BODY
    (41) FOR_STATEMENT -> . FOR ID = RANGE BODY
    (10) ASSIGNMENT -> . LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION
    (31) KEYWORD -> . PRINT SEQUENCE
    (32) KEYWORD -> . BREAK
    (33) KEYWORD -> . CONTINUE
    (34) KEYWORD -> . RETURN EXPRESSION
    (11) LEFT_ASSIGNMENT -> . ID
    (12) LEFT_ASSIGNMENT -> . ACCESS
    (13) ACCESS -> . ID [ SEQUENCE ]

    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    PRINT           shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    RETURN          shift and go to state 18
    ID              shift and go to state 13

    start                          shift and go to state 1
    INSTRUCTIONS                   shift and go to state 2
    INSTRUCTION                    shift and go to state 3
    STATEMENT                      shift and go to state 4
    IF_STATEMENT                   shift and go to state 5
    WHILE_STATEMENT                shift and go to state 6
    FOR_STATEMENT                  shift and go to state 7
    ASSIGNMENT                     shift and go to state 8
    KEYWORD                        shift and go to state 9
    LEFT_ASSIGNMENT                shift and go to state 14
    ACCESS                         shift and go to state 19

state 1

    (0) S' -> start .



state 2

    (1) start -> INSTRUCTIONS .
    (2) INSTRUCTIONS -> INSTRUCTIONS . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . IF_STATEMENT
    (6) INSTRUCTION -> . WHILE_STATEMENT
    (7) INSTRUCTION -> . FOR_STATEMENT
    (8) STATEMENT -> . ASSIGNMENT
    (9) STATEMENT -> . KEYWORD
    (38) IF_STATEMENT -> . IF ( CONDITION ) BODY
    (39) IF_STATEMENT -> . IF ( CONDITION ) BODY ELSE BODY
    (40) WHILE_STATEMENT -> . WHILE ( CONDITION ) BODY
    (41) FOR_STATEMENT -> . FOR ID = RANGE BODY
    (10) ASSIGNMENT -> . LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION
    (31) KEYWORD -> . PRINT SEQUENCE
    (32) KEYWORD -> . BREAK
    (33) KEYWORD -> . CONTINUE
    (34) KEYWORD -> . RETURN EXPRESSION
    (11) LEFT_ASSIGNMENT -> . ID
    (12) LEFT_ASSIGNMENT -> . ACCESS
    (13) ACCESS -> . ID [ SEQUENCE ]

    $end            reduce using rule 1 (start -> INSTRUCTIONS .)
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    PRINT           shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    RETURN          shift and go to state 18
    ID              shift and go to state 13

    INSTRUCTION                    shift and go to state 20
    STATEMENT                      shift and go to state 4
    IF_STATEMENT                   shift and go to state 5
    WHILE_STATEMENT                shift and go to state 6
    FOR_STATEMENT                  shift and go to state 7
    ASSIGNMENT                     shift and go to state 8
    KEYWORD                        shift and go to state 9
    LEFT_ASSIGNMENT                shift and go to state 14
    ACCESS                         shift and go to state 19

state 3

    (3) INSTRUCTIONS -> INSTRUCTION .

    IF              reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    WHILE           reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    FOR             reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    PRINT           reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    BREAK           reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    CONTINUE        reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    RETURN          reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    ID              reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    $end            reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    }               reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)


state 4

    (4) INSTRUCTION -> STATEMENT . ;

    ;               shift and go to state 21


state 5

    (5) INSTRUCTION -> IF_STATEMENT .

    IF              reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    WHILE           reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    FOR             reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    PRINT           reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    BREAK           reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    CONTINUE        reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    RETURN          reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    ID              reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    $end            reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    ELSE            reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)
    }               reduce using rule 5 (INSTRUCTION -> IF_STATEMENT .)


state 6

    (6) INSTRUCTION -> WHILE_STATEMENT .

    IF              reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    WHILE           reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    FOR             reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    PRINT           reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    BREAK           reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    CONTINUE        reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    RETURN          reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    ID              reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    $end            reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    ELSE            reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)
    }               reduce using rule 6 (INSTRUCTION -> WHILE_STATEMENT .)


state 7

    (7) INSTRUCTION -> FOR_STATEMENT .

    IF              reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    WHILE           reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    FOR             reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    PRINT           reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    BREAK           reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    CONTINUE        reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    RETURN          reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    ID              reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    $end            reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    ELSE            reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)
    }               reduce using rule 7 (INSTRUCTION -> FOR_STATEMENT .)


state 8

    (8) STATEMENT -> ASSIGNMENT .

    ;               reduce using rule 8 (STATEMENT -> ASSIGNMENT .)


state 9

    (9) STATEMENT -> KEYWORD .

    ;               reduce using rule 9 (STATEMENT -> KEYWORD .)


state 10

    (38) IF_STATEMENT -> IF . ( CONDITION ) BODY
    (39) IF_STATEMENT -> IF . ( CONDITION ) BODY ELSE BODY

    (               shift and go to state 22


state 11

    (40) WHILE_STATEMENT -> WHILE . ( CONDITION ) BODY

    (               shift and go to state 23


state 12

    (41) FOR_STATEMENT -> FOR . ID = RANGE BODY

    ID              shift and go to state 24


state 13

    (11) LEFT_ASSIGNMENT -> ID .
    (13) ACCESS -> ID . [ SEQUENCE ]

    =               reduce using rule 11 (LEFT_ASSIGNMENT -> ID .)
    PLUS_ASSIGN     reduce using rule 11 (LEFT_ASSIGNMENT -> ID .)
    MINUS_ASSIGN    reduce using rule 11 (LEFT_ASSIGNMENT -> ID .)
    TIMES_ASSIGN    reduce using rule 11 (LEFT_ASSIGNMENT -> ID .)
    DIVIDE_ASSIGN   reduce using rule 11 (LEFT_ASSIGNMENT -> ID .)
    [               shift and go to state 25


state 14

    (10) ASSIGNMENT -> LEFT_ASSIGNMENT . ASSIGNMENT_OPERATOR EXPRESSION
    (44) ASSIGNMENT_OPERATOR -> . =
    (45) ASSIGNMENT_OPERATOR -> . PLUS_ASSIGN
    (46) ASSIGNMENT_OPERATOR -> . MINUS_ASSIGN
    (47) ASSIGNMENT_OPERATOR -> . TIMES_ASSIGN
    (48) ASSIGNMENT_OPERATOR -> . DIVIDE_ASSIGN

    =               shift and go to state 27
    PLUS_ASSIGN     shift and go to state 28
    MINUS_ASSIGN    shift and go to state 29
    TIMES_ASSIGN    shift and go to state 30
    DIVIDE_ASSIGN   shift and go to state 31

    ASSIGNMENT_OPERATOR            shift and go to state 26

state 15

    (31) KEYWORD -> PRINT . SEQUENCE
    (14) SEQUENCE -> . SEQUENCE , EXPRESSION
    (15) SEQUENCE -> . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    SEQUENCE                       shift and go to state 32
    EXPRESSION                     shift and go to state 33
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 16

    (32) KEYWORD -> BREAK .

    ;               reduce using rule 32 (KEYWORD -> BREAK .)


state 17

    (33) KEYWORD -> CONTINUE .

    ;               reduce using rule 33 (KEYWORD -> CONTINUE .)


state 18

    (34) KEYWORD -> RETURN . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    EXPRESSION                     shift and go to state 48
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 19

    (12) LEFT_ASSIGNMENT -> ACCESS .

    =               reduce using rule 12 (LEFT_ASSIGNMENT -> ACCESS .)
    PLUS_ASSIGN     reduce using rule 12 (LEFT_ASSIGNMENT -> ACCESS .)
    MINUS_ASSIGN    reduce using rule 12 (LEFT_ASSIGNMENT -> ACCESS .)
    TIMES_ASSIGN    reduce using rule 12 (LEFT_ASSIGNMENT -> ACCESS .)
    DIVIDE_ASSIGN   reduce using rule 12 (LEFT_ASSIGNMENT -> ACCESS .)


state 20

    (2) INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .

    IF              reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    WHILE           reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    FOR             reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    PRINT           reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    BREAK           reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    CONTINUE        reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    RETURN          reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    ID              reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    $end            reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    }               reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)


state 21

    (4) INSTRUCTION -> STATEMENT ; .

    IF              reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    WHILE           reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    FOR             reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    PRINT           reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    BREAK           reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    CONTINUE        reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    RETURN          reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    ID              reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    $end            reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    ELSE            reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    }               reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)


state 22

    (38) IF_STATEMENT -> IF ( . CONDITION ) BODY
    (39) IF_STATEMENT -> IF ( . CONDITION ) BODY ELSE BODY
    (35) CONDITION -> . EXPRESSION COMPARISION_OPERATOR EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    CONDITION                      shift and go to state 49
    EXPRESSION                     shift and go to state 50
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 23

    (40) WHILE_STATEMENT -> WHILE ( . CONDITION ) BODY
    (35) CONDITION -> . EXPRESSION COMPARISION_OPERATOR EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    CONDITION                      shift and go to state 51
    EXPRESSION                     shift and go to state 50
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 24

    (41) FOR_STATEMENT -> FOR ID . = RANGE BODY

    =               shift and go to state 52


state 25

    (13) ACCESS -> ID [ . SEQUENCE ]
    (14) SEQUENCE -> . SEQUENCE , EXPRESSION
    (15) SEQUENCE -> . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    SEQUENCE                       shift and go to state 53
    EXPRESSION                     shift and go to state 33
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 26

    (10) ASSIGNMENT -> LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    EXPRESSION                     shift and go to state 54
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 27

    (44) ASSIGNMENT_OPERATOR -> = .

    -               reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)
    (               reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)
    FLOAT           reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)
    INT             reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)
    STRING          reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)
    ID              reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)
    EYE             reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)
    ZEROS           reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)
    ONES            reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)
    [               reduce using rule 44 (ASSIGNMENT_OPERATOR -> = .)


state 28

    (45) ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .

    -               reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)
    (               reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)
    FLOAT           reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)
    INT             reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)
    STRING          reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)
    ID              reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)
    EYE             reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)
    ZEROS           reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)
    ONES            reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)
    [               reduce using rule 45 (ASSIGNMENT_OPERATOR -> PLUS_ASSIGN .)


state 29

    (46) ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .

    -               reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)
    (               reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)
    FLOAT           reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)
    INT             reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)
    STRING          reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)
    ID              reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)
    EYE             reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)
    ZEROS           reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)
    ONES            reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)
    [               reduce using rule 46 (ASSIGNMENT_OPERATOR -> MINUS_ASSIGN .)


state 30

    (47) ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .

    -               reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)
    (               reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)
    FLOAT           reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)
    INT             reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)
    STRING          reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)
    ID              reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)
    EYE             reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)
    ZEROS           reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)
    ONES            reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)
    [               reduce using rule 47 (ASSIGNMENT_OPERATOR -> TIMES_ASSIGN .)


state 31

    (48) ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .

    -               reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)
    (               reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)
    FLOAT           reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)
    INT             reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)
    STRING          reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)
    ID              reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)
    EYE             reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)
    ZEROS           reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)
    ONES            reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)
    [               reduce using rule 48 (ASSIGNMENT_OPERATOR -> DIVIDE_ASSIGN .)


state 32

    (31) KEYWORD -> PRINT SEQUENCE .
    (14) SEQUENCE -> SEQUENCE . , EXPRESSION

    ;               reduce using rule 31 (KEYWORD -> PRINT SEQUENCE .)
    ,               shift and go to state 55


state 33

    (15) SEQUENCE -> EXPRESSION .
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    ,               reduce using rule 15 (SEQUENCE -> EXPRESSION .)
    ;               reduce using rule 15 (SEQUENCE -> EXPRESSION .)
    ]               reduce using rule 15 (SEQUENCE -> EXPRESSION .)
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 34

    (25) EXPRESSION -> VALUE .

    '               reduce using rule 25 (EXPRESSION -> VALUE .)
    +               reduce using rule 25 (EXPRESSION -> VALUE .)
    -               reduce using rule 25 (EXPRESSION -> VALUE .)
    *               reduce using rule 25 (EXPRESSION -> VALUE .)
    /               reduce using rule 25 (EXPRESSION -> VALUE .)
    M_PLUS          reduce using rule 25 (EXPRESSION -> VALUE .)
    M_MINUS         reduce using rule 25 (EXPRESSION -> VALUE .)
    M_TIMES         reduce using rule 25 (EXPRESSION -> VALUE .)
    M_DIVIDE        reduce using rule 25 (EXPRESSION -> VALUE .)
    ,               reduce using rule 25 (EXPRESSION -> VALUE .)
    ;               reduce using rule 25 (EXPRESSION -> VALUE .)
    <               reduce using rule 25 (EXPRESSION -> VALUE .)
    >               reduce using rule 25 (EXPRESSION -> VALUE .)
    EQ              reduce using rule 25 (EXPRESSION -> VALUE .)
    NEQ             reduce using rule 25 (EXPRESSION -> VALUE .)
    GE              reduce using rule 25 (EXPRESSION -> VALUE .)
    LE              reduce using rule 25 (EXPRESSION -> VALUE .)
    ]               reduce using rule 25 (EXPRESSION -> VALUE .)
    )               reduce using rule 25 (EXPRESSION -> VALUE .)
    :               reduce using rule 25 (EXPRESSION -> VALUE .)
    {               reduce using rule 25 (EXPRESSION -> VALUE .)
    IF              reduce using rule 25 (EXPRESSION -> VALUE .)
    WHILE           reduce using rule 25 (EXPRESSION -> VALUE .)
    FOR             reduce using rule 25 (EXPRESSION -> VALUE .)
    PRINT           reduce using rule 25 (EXPRESSION -> VALUE .)
    BREAK           reduce using rule 25 (EXPRESSION -> VALUE .)
    CONTINUE        reduce using rule 25 (EXPRESSION -> VALUE .)
    RETURN          reduce using rule 25 (EXPRESSION -> VALUE .)
    ID              reduce using rule 25 (EXPRESSION -> VALUE .)


state 35

    (26) EXPRESSION -> - . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    EXPRESSION                     shift and go to state 66
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 36

    (28) EXPRESSION -> ( . EXPRESSION )
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    EXPRESSION                     shift and go to state 67
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 37

    (30) EXPRESSION -> FUNCTION . ( EXPRESSION )

    (               shift and go to state 68


state 38

    (16) VALUE -> FLOAT .

    '               reduce using rule 16 (VALUE -> FLOAT .)
    +               reduce using rule 16 (VALUE -> FLOAT .)
    -               reduce using rule 16 (VALUE -> FLOAT .)
    *               reduce using rule 16 (VALUE -> FLOAT .)
    /               reduce using rule 16 (VALUE -> FLOAT .)
    M_PLUS          reduce using rule 16 (VALUE -> FLOAT .)
    M_MINUS         reduce using rule 16 (VALUE -> FLOAT .)
    M_TIMES         reduce using rule 16 (VALUE -> FLOAT .)
    M_DIVIDE        reduce using rule 16 (VALUE -> FLOAT .)
    ,               reduce using rule 16 (VALUE -> FLOAT .)
    ;               reduce using rule 16 (VALUE -> FLOAT .)
    <               reduce using rule 16 (VALUE -> FLOAT .)
    >               reduce using rule 16 (VALUE -> FLOAT .)
    EQ              reduce using rule 16 (VALUE -> FLOAT .)
    NEQ             reduce using rule 16 (VALUE -> FLOAT .)
    GE              reduce using rule 16 (VALUE -> FLOAT .)
    LE              reduce using rule 16 (VALUE -> FLOAT .)
    ]               reduce using rule 16 (VALUE -> FLOAT .)
    )               reduce using rule 16 (VALUE -> FLOAT .)
    :               reduce using rule 16 (VALUE -> FLOAT .)
    {               reduce using rule 16 (VALUE -> FLOAT .)
    IF              reduce using rule 16 (VALUE -> FLOAT .)
    WHILE           reduce using rule 16 (VALUE -> FLOAT .)
    FOR             reduce using rule 16 (VALUE -> FLOAT .)
    PRINT           reduce using rule 16 (VALUE -> FLOAT .)
    BREAK           reduce using rule 16 (VALUE -> FLOAT .)
    CONTINUE        reduce using rule 16 (VALUE -> FLOAT .)
    RETURN          reduce using rule 16 (VALUE -> FLOAT .)
    ID              reduce using rule 16 (VALUE -> FLOAT .)


state 39

    (17) VALUE -> INT .

    '               reduce using rule 17 (VALUE -> INT .)
    +               reduce using rule 17 (VALUE -> INT .)
    -               reduce using rule 17 (VALUE -> INT .)
    *               reduce using rule 17 (VALUE -> INT .)
    /               reduce using rule 17 (VALUE -> INT .)
    M_PLUS          reduce using rule 17 (VALUE -> INT .)
    M_MINUS         reduce using rule 17 (VALUE -> INT .)
    M_TIMES         reduce using rule 17 (VALUE -> INT .)
    M_DIVIDE        reduce using rule 17 (VALUE -> INT .)
    ,               reduce using rule 17 (VALUE -> INT .)
    ;               reduce using rule 17 (VALUE -> INT .)
    <               reduce using rule 17 (VALUE -> INT .)
    >               reduce using rule 17 (VALUE -> INT .)
    EQ              reduce using rule 17 (VALUE -> INT .)
    NEQ             reduce using rule 17 (VALUE -> INT .)
    GE              reduce using rule 17 (VALUE -> INT .)
    LE              reduce using rule 17 (VALUE -> INT .)
    ]               reduce using rule 17 (VALUE -> INT .)
    )               reduce using rule 17 (VALUE -> INT .)
    :               reduce using rule 17 (VALUE -> INT .)
    {               reduce using rule 17 (VALUE -> INT .)
    IF              reduce using rule 17 (VALUE -> INT .)
    WHILE           reduce using rule 17 (VALUE -> INT .)
    FOR             reduce using rule 17 (VALUE -> INT .)
    PRINT           reduce using rule 17 (VALUE -> INT .)
    BREAK           reduce using rule 17 (VALUE -> INT .)
    CONTINUE        reduce using rule 17 (VALUE -> INT .)
    RETURN          reduce using rule 17 (VALUE -> INT .)
    ID              reduce using rule 17 (VALUE -> INT .)


state 40

    (18) VALUE -> STRING .

    '               reduce using rule 18 (VALUE -> STRING .)
    +               reduce using rule 18 (VALUE -> STRING .)
    -               reduce using rule 18 (VALUE -> STRING .)
    *               reduce using rule 18 (VALUE -> STRING .)
    /               reduce using rule 18 (VALUE -> STRING .)
    M_PLUS          reduce using rule 18 (VALUE -> STRING .)
    M_MINUS         reduce using rule 18 (VALUE -> STRING .)
    M_TIMES         reduce using rule 18 (VALUE -> STRING .)
    M_DIVIDE        reduce using rule 18 (VALUE -> STRING .)
    ,               reduce using rule 18 (VALUE -> STRING .)
    ;               reduce using rule 18 (VALUE -> STRING .)
    <               reduce using rule 18 (VALUE -> STRING .)
    >               reduce using rule 18 (VALUE -> STRING .)
    EQ              reduce using rule 18 (VALUE -> STRING .)
    NEQ             reduce using rule 18 (VALUE -> STRING .)
    GE              reduce using rule 18 (VALUE -> STRING .)
    LE              reduce using rule 18 (VALUE -> STRING .)
    ]               reduce using rule 18 (VALUE -> STRING .)
    )               reduce using rule 18 (VALUE -> STRING .)
    :               reduce using rule 18 (VALUE -> STRING .)
    {               reduce using rule 18 (VALUE -> STRING .)
    IF              reduce using rule 18 (VALUE -> STRING .)
    WHILE           reduce using rule 18 (VALUE -> STRING .)
    FOR             reduce using rule 18 (VALUE -> STRING .)
    PRINT           reduce using rule 18 (VALUE -> STRING .)
    BREAK           reduce using rule 18 (VALUE -> STRING .)
    CONTINUE        reduce using rule 18 (VALUE -> STRING .)
    RETURN          reduce using rule 18 (VALUE -> STRING .)
    ID              reduce using rule 18 (VALUE -> STRING .)


state 41

    (19) VALUE -> ID .
    (13) ACCESS -> ID . [ SEQUENCE ]

    '               reduce using rule 19 (VALUE -> ID .)
    +               reduce using rule 19 (VALUE -> ID .)
    -               reduce using rule 19 (VALUE -> ID .)
    *               reduce using rule 19 (VALUE -> ID .)
    /               reduce using rule 19 (VALUE -> ID .)
    M_PLUS          reduce using rule 19 (VALUE -> ID .)
    M_MINUS         reduce using rule 19 (VALUE -> ID .)
    M_TIMES         reduce using rule 19 (VALUE -> ID .)
    M_DIVIDE        reduce using rule 19 (VALUE -> ID .)
    ,               reduce using rule 19 (VALUE -> ID .)
    ;               reduce using rule 19 (VALUE -> ID .)
    <               reduce using rule 19 (VALUE -> ID .)
    >               reduce using rule 19 (VALUE -> ID .)
    EQ              reduce using rule 19 (VALUE -> ID .)
    NEQ             reduce using rule 19 (VALUE -> ID .)
    GE              reduce using rule 19 (VALUE -> ID .)
    LE              reduce using rule 19 (VALUE -> ID .)
    ]               reduce using rule 19 (VALUE -> ID .)
    )               reduce using rule 19 (VALUE -> ID .)
    :               reduce using rule 19 (VALUE -> ID .)
    {               reduce using rule 19 (VALUE -> ID .)
    IF              reduce using rule 19 (VALUE -> ID .)
    WHILE           reduce using rule 19 (VALUE -> ID .)
    FOR             reduce using rule 19 (VALUE -> ID .)
    PRINT           reduce using rule 19 (VALUE -> ID .)
    BREAK           reduce using rule 19 (VALUE -> ID .)
    CONTINUE        reduce using rule 19 (VALUE -> ID .)
    RETURN          reduce using rule 19 (VALUE -> ID .)
    ID              reduce using rule 19 (VALUE -> ID .)
    [               shift and go to state 25


state 42

    (20) VALUE -> MATRIX .

    '               reduce using rule 20 (VALUE -> MATRIX .)
    +               reduce using rule 20 (VALUE -> MATRIX .)
    -               reduce using rule 20 (VALUE -> MATRIX .)
    *               reduce using rule 20 (VALUE -> MATRIX .)
    /               reduce using rule 20 (VALUE -> MATRIX .)
    M_PLUS          reduce using rule 20 (VALUE -> MATRIX .)
    M_MINUS         reduce using rule 20 (VALUE -> MATRIX .)
    M_TIMES         reduce using rule 20 (VALUE -> MATRIX .)
    M_DIVIDE        reduce using rule 20 (VALUE -> MATRIX .)
    ,               reduce using rule 20 (VALUE -> MATRIX .)
    ;               reduce using rule 20 (VALUE -> MATRIX .)
    <               reduce using rule 20 (VALUE -> MATRIX .)
    >               reduce using rule 20 (VALUE -> MATRIX .)
    EQ              reduce using rule 20 (VALUE -> MATRIX .)
    NEQ             reduce using rule 20 (VALUE -> MATRIX .)
    GE              reduce using rule 20 (VALUE -> MATRIX .)
    LE              reduce using rule 20 (VALUE -> MATRIX .)
    ]               reduce using rule 20 (VALUE -> MATRIX .)
    )               reduce using rule 20 (VALUE -> MATRIX .)
    :               reduce using rule 20 (VALUE -> MATRIX .)
    {               reduce using rule 20 (VALUE -> MATRIX .)
    IF              reduce using rule 20 (VALUE -> MATRIX .)
    WHILE           reduce using rule 20 (VALUE -> MATRIX .)
    FOR             reduce using rule 20 (VALUE -> MATRIX .)
    PRINT           reduce using rule 20 (VALUE -> MATRIX .)
    BREAK           reduce using rule 20 (VALUE -> MATRIX .)
    CONTINUE        reduce using rule 20 (VALUE -> MATRIX .)
    RETURN          reduce using rule 20 (VALUE -> MATRIX .)
    ID              reduce using rule 20 (VALUE -> MATRIX .)


state 43

    (21) VALUE -> ACCESS .

    '               reduce using rule 21 (VALUE -> ACCESS .)
    +               reduce using rule 21 (VALUE -> ACCESS .)
    -               reduce using rule 21 (VALUE -> ACCESS .)
    *               reduce using rule 21 (VALUE -> ACCESS .)
    /               reduce using rule 21 (VALUE -> ACCESS .)
    M_PLUS          reduce using rule 21 (VALUE -> ACCESS .)
    M_MINUS         reduce using rule 21 (VALUE -> ACCESS .)
    M_TIMES         reduce using rule 21 (VALUE -> ACCESS .)
    M_DIVIDE        reduce using rule 21 (VALUE -> ACCESS .)
    ,               reduce using rule 21 (VALUE -> ACCESS .)
    ;               reduce using rule 21 (VALUE -> ACCESS .)
    <               reduce using rule 21 (VALUE -> ACCESS .)
    >               reduce using rule 21 (VALUE -> ACCESS .)
    EQ              reduce using rule 21 (VALUE -> ACCESS .)
    NEQ             reduce using rule 21 (VALUE -> ACCESS .)
    GE              reduce using rule 21 (VALUE -> ACCESS .)
    LE              reduce using rule 21 (VALUE -> ACCESS .)
    ]               reduce using rule 21 (VALUE -> ACCESS .)
    )               reduce using rule 21 (VALUE -> ACCESS .)
    :               reduce using rule 21 (VALUE -> ACCESS .)
    {               reduce using rule 21 (VALUE -> ACCESS .)
    IF              reduce using rule 21 (VALUE -> ACCESS .)
    WHILE           reduce using rule 21 (VALUE -> ACCESS .)
    FOR             reduce using rule 21 (VALUE -> ACCESS .)
    PRINT           reduce using rule 21 (VALUE -> ACCESS .)
    BREAK           reduce using rule 21 (VALUE -> ACCESS .)
    CONTINUE        reduce using rule 21 (VALUE -> ACCESS .)
    RETURN          reduce using rule 21 (VALUE -> ACCESS .)
    ID              reduce using rule 21 (VALUE -> ACCESS .)


state 44

    (63) FUNCTION -> EYE .

    (               reduce using rule 63 (FUNCTION -> EYE .)


state 45

    (64) FUNCTION -> ZEROS .

    (               reduce using rule 64 (FUNCTION -> ZEROS .)


state 46

    (65) FUNCTION -> ONES .

    (               reduce using rule 65 (FUNCTION -> ONES .)


state 47

    (22) MATRIX -> [ . ROWS ]
    (23) ROWS -> . ROWS ; SEQUENCE
    (24) ROWS -> . SEQUENCE
    (14) SEQUENCE -> . SEQUENCE , EXPRESSION
    (15) SEQUENCE -> . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    ROWS                           shift and go to state 69
    SEQUENCE                       shift and go to state 70
    EXPRESSION                     shift and go to state 33
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 48

    (34) KEYWORD -> RETURN EXPRESSION .
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    ;               reduce using rule 34 (KEYWORD -> RETURN EXPRESSION .)
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 49

    (38) IF_STATEMENT -> IF ( CONDITION . ) BODY
    (39) IF_STATEMENT -> IF ( CONDITION . ) BODY ELSE BODY

    )               shift and go to state 71


state 50

    (35) CONDITION -> EXPRESSION . COMPARISION_OPERATOR EXPRESSION
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (49) COMPARISION_OPERATOR -> . <
    (50) COMPARISION_OPERATOR -> . >
    (51) COMPARISION_OPERATOR -> . EQ
    (52) COMPARISION_OPERATOR -> . NEQ
    (53) COMPARISION_OPERATOR -> . GE
    (54) COMPARISION_OPERATOR -> . LE
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    '               shift and go to state 56
    <               shift and go to state 73
    >               shift and go to state 74
    EQ              shift and go to state 75
    NEQ             shift and go to state 76
    GE              shift and go to state 77
    LE              shift and go to state 78
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    COMPARISION_OPERATOR           shift and go to state 72
    MATHEMATICAL_OPERATOR          shift and go to state 57

state 51

    (40) WHILE_STATEMENT -> WHILE ( CONDITION . ) BODY

    )               shift and go to state 79


state 52

    (41) FOR_STATEMENT -> FOR ID = . RANGE BODY
    (42) RANGE -> . EXPRESSION : EXPRESSION
    (43) RANGE -> . EXPRESSION : EXPRESSION : EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    RANGE                          shift and go to state 80
    EXPRESSION                     shift and go to state 81
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 53

    (13) ACCESS -> ID [ SEQUENCE . ]
    (14) SEQUENCE -> SEQUENCE . , EXPRESSION

    ]               shift and go to state 82
    ,               shift and go to state 55


state 54

    (10) ASSIGNMENT -> LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION .
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    ;               reduce using rule 10 (ASSIGNMENT -> LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION .)
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 55

    (14) SEQUENCE -> SEQUENCE , . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    EXPRESSION                     shift and go to state 83
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 56

    (27) EXPRESSION -> EXPRESSION ' .

    '               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    +               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    -               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    *               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    /               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    M_PLUS          reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    M_MINUS         reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    M_TIMES         reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    M_DIVIDE        reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    ,               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    ;               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    <               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    >               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    EQ              reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    NEQ             reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    GE              reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    LE              reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    ]               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    )               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    :               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    {               reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    IF              reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    WHILE           reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    FOR             reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    PRINT           reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    BREAK           reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    CONTINUE        reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    RETURN          reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)
    ID              reduce using rule 27 (EXPRESSION -> EXPRESSION ' .)


state 57

    (29) EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    EXPRESSION                     shift and go to state 84
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 58

    (55) MATHEMATICAL_OPERATOR -> + .

    -               reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)
    (               reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)
    FLOAT           reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)
    INT             reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)
    STRING          reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)
    ID              reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)
    EYE             reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)
    ZEROS           reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)
    ONES            reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)
    [               reduce using rule 55 (MATHEMATICAL_OPERATOR -> + .)


state 59

    (56) MATHEMATICAL_OPERATOR -> - .

    -               reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)
    (               reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)
    FLOAT           reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)
    INT             reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)
    STRING          reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)
    ID              reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)
    EYE             reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)
    ZEROS           reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)
    ONES            reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)
    [               reduce using rule 56 (MATHEMATICAL_OPERATOR -> - .)


state 60

    (57) MATHEMATICAL_OPERATOR -> * .

    -               reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)
    (               reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)
    FLOAT           reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)
    INT             reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)
    STRING          reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)
    ID              reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)
    EYE             reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)
    ZEROS           reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)
    ONES            reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)
    [               reduce using rule 57 (MATHEMATICAL_OPERATOR -> * .)


state 61

    (58) MATHEMATICAL_OPERATOR -> / .

    -               reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)
    (               reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)
    FLOAT           reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)
    INT             reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)
    STRING          reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)
    ID              reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)
    EYE             reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)
    ZEROS           reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)
    ONES            reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)
    [               reduce using rule 58 (MATHEMATICAL_OPERATOR -> / .)


state 62

    (59) MATHEMATICAL_OPERATOR -> M_PLUS .

    -               reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)
    (               reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)
    FLOAT           reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)
    INT             reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)
    STRING          reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)
    ID              reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)
    EYE             reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)
    ZEROS           reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)
    ONES            reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)
    [               reduce using rule 59 (MATHEMATICAL_OPERATOR -> M_PLUS .)


state 63

    (60) MATHEMATICAL_OPERATOR -> M_MINUS .

    -               reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)
    (               reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)
    FLOAT           reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)
    INT             reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)
    STRING          reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)
    ID              reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)
    EYE             reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)
    ZEROS           reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)
    ONES            reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)
    [               reduce using rule 60 (MATHEMATICAL_OPERATOR -> M_MINUS .)


state 64

    (61) MATHEMATICAL_OPERATOR -> M_TIMES .

    -               reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)
    (               reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)
    FLOAT           reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)
    INT             reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)
    STRING          reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)
    ID              reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)
    EYE             reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)
    ZEROS           reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)
    ONES            reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)
    [               reduce using rule 61 (MATHEMATICAL_OPERATOR -> M_TIMES .)


state 65

    (62) MATHEMATICAL_OPERATOR -> M_DIVIDE .

    -               reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)
    (               reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)
    FLOAT           reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)
    INT             reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)
    STRING          reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)
    ID              reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)
    EYE             reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)
    ZEROS           reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)
    ONES            reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)
    [               reduce using rule 62 (MATHEMATICAL_OPERATOR -> M_DIVIDE .)


state 66

    (26) EXPRESSION -> - EXPRESSION .
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    '               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    +               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    -               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    M_PLUS          reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    M_MINUS         reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    M_TIMES         reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    M_DIVIDE        reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    ,               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    ;               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    <               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    >               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    EQ              reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    NEQ             reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    GE              reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    LE              reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    ]               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    )               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    :               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    {               reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    IF              reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    WHILE           reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    FOR             reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    PRINT           reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    BREAK           reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    CONTINUE        reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    RETURN          reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    ID              reduce using rule 26 (EXPRESSION -> - EXPRESSION .)
    *               shift and go to state 60
    /               shift and go to state 61

  ! *               [ reduce using rule 26 (EXPRESSION -> - EXPRESSION .) ]
  ! /               [ reduce using rule 26 (EXPRESSION -> - EXPRESSION .) ]
  ! '               [ shift and go to state 56 ]
  ! +               [ shift and go to state 58 ]
  ! -               [ shift and go to state 59 ]
  ! M_PLUS          [ shift and go to state 62 ]
  ! M_MINUS         [ shift and go to state 63 ]
  ! M_TIMES         [ shift and go to state 64 ]
  ! M_DIVIDE        [ shift and go to state 65 ]

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 67

    (28) EXPRESSION -> ( EXPRESSION . )
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    )               shift and go to state 85
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 68

    (30) EXPRESSION -> FUNCTION ( . EXPRESSION )
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    FUNCTION                       shift and go to state 37
    EXPRESSION                     shift and go to state 86
    VALUE                          shift and go to state 34
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 69

    (22) MATRIX -> [ ROWS . ]
    (23) ROWS -> ROWS . ; SEQUENCE

    ]               shift and go to state 87
    ;               shift and go to state 88


state 70

    (24) ROWS -> SEQUENCE .
    (14) SEQUENCE -> SEQUENCE . , EXPRESSION

    ]               reduce using rule 24 (ROWS -> SEQUENCE .)
    ;               reduce using rule 24 (ROWS -> SEQUENCE .)
    ,               shift and go to state 55


state 71

    (38) IF_STATEMENT -> IF ( CONDITION ) . BODY
    (39) IF_STATEMENT -> IF ( CONDITION ) . BODY ELSE BODY
    (36) BODY -> . { INSTRUCTIONS }
    (37) BODY -> . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . IF_STATEMENT
    (6) INSTRUCTION -> . WHILE_STATEMENT
    (7) INSTRUCTION -> . FOR_STATEMENT
    (8) STATEMENT -> . ASSIGNMENT
    (9) STATEMENT -> . KEYWORD
    (38) IF_STATEMENT -> . IF ( CONDITION ) BODY
    (39) IF_STATEMENT -> . IF ( CONDITION ) BODY ELSE BODY
    (40) WHILE_STATEMENT -> . WHILE ( CONDITION ) BODY
    (41) FOR_STATEMENT -> . FOR ID = RANGE BODY
    (10) ASSIGNMENT -> . LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION
    (31) KEYWORD -> . PRINT SEQUENCE
    (32) KEYWORD -> . BREAK
    (33) KEYWORD -> . CONTINUE
    (34) KEYWORD -> . RETURN EXPRESSION
    (11) LEFT_ASSIGNMENT -> . ID
    (12) LEFT_ASSIGNMENT -> . ACCESS
    (13) ACCESS -> . ID [ SEQUENCE ]

    {               shift and go to state 90
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    PRINT           shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    RETURN          shift and go to state 18
    ID              shift and go to state 13

    BODY                           shift and go to state 89
    INSTRUCTION                    shift and go to state 91
    STATEMENT                      shift and go to state 4
    IF_STATEMENT                   shift and go to state 5
    WHILE_STATEMENT                shift and go to state 6
    FOR_STATEMENT                  shift and go to state 7
    ASSIGNMENT                     shift and go to state 8
    KEYWORD                        shift and go to state 9
    LEFT_ASSIGNMENT                shift and go to state 14
    ACCESS                         shift and go to state 19

state 72

    (35) CONDITION -> EXPRESSION COMPARISION_OPERATOR . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    EXPRESSION                     shift and go to state 92
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 73

    (49) COMPARISION_OPERATOR -> < .

    -               reduce using rule 49 (COMPARISION_OPERATOR -> < .)
    (               reduce using rule 49 (COMPARISION_OPERATOR -> < .)
    FLOAT           reduce using rule 49 (COMPARISION_OPERATOR -> < .)
    INT             reduce using rule 49 (COMPARISION_OPERATOR -> < .)
    STRING          reduce using rule 49 (COMPARISION_OPERATOR -> < .)
    ID              reduce using rule 49 (COMPARISION_OPERATOR -> < .)
    EYE             reduce using rule 49 (COMPARISION_OPERATOR -> < .)
    ZEROS           reduce using rule 49 (COMPARISION_OPERATOR -> < .)
    ONES            reduce using rule 49 (COMPARISION_OPERATOR -> < .)
    [               reduce using rule 49 (COMPARISION_OPERATOR -> < .)


state 74

    (50) COMPARISION_OPERATOR -> > .

    -               reduce using rule 50 (COMPARISION_OPERATOR -> > .)
    (               reduce using rule 50 (COMPARISION_OPERATOR -> > .)
    FLOAT           reduce using rule 50 (COMPARISION_OPERATOR -> > .)
    INT             reduce using rule 50 (COMPARISION_OPERATOR -> > .)
    STRING          reduce using rule 50 (COMPARISION_OPERATOR -> > .)
    ID              reduce using rule 50 (COMPARISION_OPERATOR -> > .)
    EYE             reduce using rule 50 (COMPARISION_OPERATOR -> > .)
    ZEROS           reduce using rule 50 (COMPARISION_OPERATOR -> > .)
    ONES            reduce using rule 50 (COMPARISION_OPERATOR -> > .)
    [               reduce using rule 50 (COMPARISION_OPERATOR -> > .)


state 75

    (51) COMPARISION_OPERATOR -> EQ .

    -               reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)
    (               reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)
    FLOAT           reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)
    INT             reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)
    STRING          reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)
    ID              reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)
    EYE             reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)
    ZEROS           reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)
    ONES            reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)
    [               reduce using rule 51 (COMPARISION_OPERATOR -> EQ .)


state 76

    (52) COMPARISION_OPERATOR -> NEQ .

    -               reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)
    (               reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)
    FLOAT           reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)
    INT             reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)
    STRING          reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)
    ID              reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)
    EYE             reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)
    ZEROS           reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)
    ONES            reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)
    [               reduce using rule 52 (COMPARISION_OPERATOR -> NEQ .)


state 77

    (53) COMPARISION_OPERATOR -> GE .

    -               reduce using rule 53 (COMPARISION_OPERATOR -> GE .)
    (               reduce using rule 53 (COMPARISION_OPERATOR -> GE .)
    FLOAT           reduce using rule 53 (COMPARISION_OPERATOR -> GE .)
    INT             reduce using rule 53 (COMPARISION_OPERATOR -> GE .)
    STRING          reduce using rule 53 (COMPARISION_OPERATOR -> GE .)
    ID              reduce using rule 53 (COMPARISION_OPERATOR -> GE .)
    EYE             reduce using rule 53 (COMPARISION_OPERATOR -> GE .)
    ZEROS           reduce using rule 53 (COMPARISION_OPERATOR -> GE .)
    ONES            reduce using rule 53 (COMPARISION_OPERATOR -> GE .)
    [               reduce using rule 53 (COMPARISION_OPERATOR -> GE .)


state 78

    (54) COMPARISION_OPERATOR -> LE .

    -               reduce using rule 54 (COMPARISION_OPERATOR -> LE .)
    (               reduce using rule 54 (COMPARISION_OPERATOR -> LE .)
    FLOAT           reduce using rule 54 (COMPARISION_OPERATOR -> LE .)
    INT             reduce using rule 54 (COMPARISION_OPERATOR -> LE .)
    STRING          reduce using rule 54 (COMPARISION_OPERATOR -> LE .)
    ID              reduce using rule 54 (COMPARISION_OPERATOR -> LE .)
    EYE             reduce using rule 54 (COMPARISION_OPERATOR -> LE .)
    ZEROS           reduce using rule 54 (COMPARISION_OPERATOR -> LE .)
    ONES            reduce using rule 54 (COMPARISION_OPERATOR -> LE .)
    [               reduce using rule 54 (COMPARISION_OPERATOR -> LE .)


state 79

    (40) WHILE_STATEMENT -> WHILE ( CONDITION ) . BODY
    (36) BODY -> . { INSTRUCTIONS }
    (37) BODY -> . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . IF_STATEMENT
    (6) INSTRUCTION -> . WHILE_STATEMENT
    (7) INSTRUCTION -> . FOR_STATEMENT
    (8) STATEMENT -> . ASSIGNMENT
    (9) STATEMENT -> . KEYWORD
    (38) IF_STATEMENT -> . IF ( CONDITION ) BODY
    (39) IF_STATEMENT -> . IF ( CONDITION ) BODY ELSE BODY
    (40) WHILE_STATEMENT -> . WHILE ( CONDITION ) BODY
    (41) FOR_STATEMENT -> . FOR ID = RANGE BODY
    (10) ASSIGNMENT -> . LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION
    (31) KEYWORD -> . PRINT SEQUENCE
    (32) KEYWORD -> . BREAK
    (33) KEYWORD -> . CONTINUE
    (34) KEYWORD -> . RETURN EXPRESSION
    (11) LEFT_ASSIGNMENT -> . ID
    (12) LEFT_ASSIGNMENT -> . ACCESS
    (13) ACCESS -> . ID [ SEQUENCE ]

    {               shift and go to state 90
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    PRINT           shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    RETURN          shift and go to state 18
    ID              shift and go to state 13

    BODY                           shift and go to state 93
    INSTRUCTION                    shift and go to state 91
    STATEMENT                      shift and go to state 4
    IF_STATEMENT                   shift and go to state 5
    WHILE_STATEMENT                shift and go to state 6
    FOR_STATEMENT                  shift and go to state 7
    ASSIGNMENT                     shift and go to state 8
    KEYWORD                        shift and go to state 9
    LEFT_ASSIGNMENT                shift and go to state 14
    ACCESS                         shift and go to state 19

state 80

    (41) FOR_STATEMENT -> FOR ID = RANGE . BODY
    (36) BODY -> . { INSTRUCTIONS }
    (37) BODY -> . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . IF_STATEMENT
    (6) INSTRUCTION -> . WHILE_STATEMENT
    (7) INSTRUCTION -> . FOR_STATEMENT
    (8) STATEMENT -> . ASSIGNMENT
    (9) STATEMENT -> . KEYWORD
    (38) IF_STATEMENT -> . IF ( CONDITION ) BODY
    (39) IF_STATEMENT -> . IF ( CONDITION ) BODY ELSE BODY
    (40) WHILE_STATEMENT -> . WHILE ( CONDITION ) BODY
    (41) FOR_STATEMENT -> . FOR ID = RANGE BODY
    (10) ASSIGNMENT -> . LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION
    (31) KEYWORD -> . PRINT SEQUENCE
    (32) KEYWORD -> . BREAK
    (33) KEYWORD -> . CONTINUE
    (34) KEYWORD -> . RETURN EXPRESSION
    (11) LEFT_ASSIGNMENT -> . ID
    (12) LEFT_ASSIGNMENT -> . ACCESS
    (13) ACCESS -> . ID [ SEQUENCE ]

    {               shift and go to state 90
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    PRINT           shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    RETURN          shift and go to state 18
    ID              shift and go to state 13

    BODY                           shift and go to state 94
    INSTRUCTION                    shift and go to state 91
    STATEMENT                      shift and go to state 4
    IF_STATEMENT                   shift and go to state 5
    WHILE_STATEMENT                shift and go to state 6
    FOR_STATEMENT                  shift and go to state 7
    ASSIGNMENT                     shift and go to state 8
    KEYWORD                        shift and go to state 9
    LEFT_ASSIGNMENT                shift and go to state 14
    ACCESS                         shift and go to state 19

state 81

    (42) RANGE -> EXPRESSION . : EXPRESSION
    (43) RANGE -> EXPRESSION . : EXPRESSION : EXPRESSION
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    :               shift and go to state 95
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 82

    (13) ACCESS -> ID [ SEQUENCE ] .

    =               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    PLUS_ASSIGN     reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    MINUS_ASSIGN    reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    TIMES_ASSIGN    reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    DIVIDE_ASSIGN   reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    '               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    +               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    -               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    *               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    /               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    M_PLUS          reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    M_MINUS         reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    M_TIMES         reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    M_DIVIDE        reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    ,               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    ;               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    <               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    >               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    EQ              reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    NEQ             reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    GE              reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    LE              reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    ]               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    )               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    :               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    {               reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    IF              reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    WHILE           reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    FOR             reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    PRINT           reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    BREAK           reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    CONTINUE        reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    RETURN          reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)
    ID              reduce using rule 13 (ACCESS -> ID [ SEQUENCE ] .)


state 83

    (14) SEQUENCE -> SEQUENCE , EXPRESSION .
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    ,               reduce using rule 14 (SEQUENCE -> SEQUENCE , EXPRESSION .)
    ;               reduce using rule 14 (SEQUENCE -> SEQUENCE , EXPRESSION .)
    ]               reduce using rule 14 (SEQUENCE -> SEQUENCE , EXPRESSION .)
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 84

    (29) EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for M_PLUS resolved as shift
  ! shift/reduce conflict for M_MINUS resolved as shift
  ! shift/reduce conflict for M_TIMES resolved as shift
  ! shift/reduce conflict for M_DIVIDE resolved as shift
    ,               reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    ;               reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    <               reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    >               reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    EQ              reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    NEQ             reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    GE              reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    LE              reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    ]               reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    )               reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    :               reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    {               reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    IF              reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    WHILE           reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    FOR             reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    PRINT           reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    BREAK           reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    CONTINUE        reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    RETURN          reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    ID              reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .)
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

  ! '               [ reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .) ]
  ! +               [ reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .) ]
  ! -               [ reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .) ]
  ! *               [ reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .) ]
  ! /               [ reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .) ]
  ! M_PLUS          [ reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .) ]
  ! M_MINUS         [ reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .) ]
  ! M_TIMES         [ reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .) ]
  ! M_DIVIDE        [ reduce using rule 29 (EXPRESSION -> EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION .) ]

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 85

    (28) EXPRESSION -> ( EXPRESSION ) .

    '               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    +               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    -               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    *               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    /               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    M_PLUS          reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    M_MINUS         reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    M_TIMES         reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    M_DIVIDE        reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    ,               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    ;               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    <               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    >               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    EQ              reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    NEQ             reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    GE              reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    LE              reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    ]               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    )               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    :               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    {               reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    IF              reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    WHILE           reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    FOR             reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    PRINT           reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    BREAK           reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    CONTINUE        reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    RETURN          reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)
    ID              reduce using rule 28 (EXPRESSION -> ( EXPRESSION ) .)


state 86

    (30) EXPRESSION -> FUNCTION ( EXPRESSION . )
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    )               shift and go to state 96
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 87

    (22) MATRIX -> [ ROWS ] .

    '               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    +               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    -               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    *               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    /               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    M_PLUS          reduce using rule 22 (MATRIX -> [ ROWS ] .)
    M_MINUS         reduce using rule 22 (MATRIX -> [ ROWS ] .)
    M_TIMES         reduce using rule 22 (MATRIX -> [ ROWS ] .)
    M_DIVIDE        reduce using rule 22 (MATRIX -> [ ROWS ] .)
    ,               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    ;               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    <               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    >               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    EQ              reduce using rule 22 (MATRIX -> [ ROWS ] .)
    NEQ             reduce using rule 22 (MATRIX -> [ ROWS ] .)
    GE              reduce using rule 22 (MATRIX -> [ ROWS ] .)
    LE              reduce using rule 22 (MATRIX -> [ ROWS ] .)
    ]               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    )               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    :               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    {               reduce using rule 22 (MATRIX -> [ ROWS ] .)
    IF              reduce using rule 22 (MATRIX -> [ ROWS ] .)
    WHILE           reduce using rule 22 (MATRIX -> [ ROWS ] .)
    FOR             reduce using rule 22 (MATRIX -> [ ROWS ] .)
    PRINT           reduce using rule 22 (MATRIX -> [ ROWS ] .)
    BREAK           reduce using rule 22 (MATRIX -> [ ROWS ] .)
    CONTINUE        reduce using rule 22 (MATRIX -> [ ROWS ] .)
    RETURN          reduce using rule 22 (MATRIX -> [ ROWS ] .)
    ID              reduce using rule 22 (MATRIX -> [ ROWS ] .)


state 88

    (23) ROWS -> ROWS ; . SEQUENCE
    (14) SEQUENCE -> . SEQUENCE , EXPRESSION
    (15) SEQUENCE -> . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    SEQUENCE                       shift and go to state 97
    EXPRESSION                     shift and go to state 33
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 89

    (38) IF_STATEMENT -> IF ( CONDITION ) BODY .
    (39) IF_STATEMENT -> IF ( CONDITION ) BODY . ELSE BODY

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    WHILE           reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    FOR             reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    PRINT           reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    BREAK           reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    CONTINUE        reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    RETURN          reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    ID              reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    $end            reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    }               reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .)
    ELSE            shift and go to state 98

  ! ELSE            [ reduce using rule 38 (IF_STATEMENT -> IF ( CONDITION ) BODY .) ]


state 90

    (36) BODY -> { . INSTRUCTIONS }
    (2) INSTRUCTIONS -> . INSTRUCTIONS INSTRUCTION
    (3) INSTRUCTIONS -> . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . IF_STATEMENT
    (6) INSTRUCTION -> . WHILE_STATEMENT
    (7) INSTRUCTION -> . FOR_STATEMENT
    (8) STATEMENT -> . ASSIGNMENT
    (9) STATEMENT -> . KEYWORD
    (38) IF_STATEMENT -> . IF ( CONDITION ) BODY
    (39) IF_STATEMENT -> . IF ( CONDITION ) BODY ELSE BODY
    (40) WHILE_STATEMENT -> . WHILE ( CONDITION ) BODY
    (41) FOR_STATEMENT -> . FOR ID = RANGE BODY
    (10) ASSIGNMENT -> . LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION
    (31) KEYWORD -> . PRINT SEQUENCE
    (32) KEYWORD -> . BREAK
    (33) KEYWORD -> . CONTINUE
    (34) KEYWORD -> . RETURN EXPRESSION
    (11) LEFT_ASSIGNMENT -> . ID
    (12) LEFT_ASSIGNMENT -> . ACCESS
    (13) ACCESS -> . ID [ SEQUENCE ]

    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    PRINT           shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    RETURN          shift and go to state 18
    ID              shift and go to state 13

    INSTRUCTIONS                   shift and go to state 99
    INSTRUCTION                    shift and go to state 3
    STATEMENT                      shift and go to state 4
    IF_STATEMENT                   shift and go to state 5
    WHILE_STATEMENT                shift and go to state 6
    FOR_STATEMENT                  shift and go to state 7
    ASSIGNMENT                     shift and go to state 8
    KEYWORD                        shift and go to state 9
    LEFT_ASSIGNMENT                shift and go to state 14
    ACCESS                         shift and go to state 19

state 91

    (37) BODY -> INSTRUCTION .

    ELSE            reduce using rule 37 (BODY -> INSTRUCTION .)
    IF              reduce using rule 37 (BODY -> INSTRUCTION .)
    WHILE           reduce using rule 37 (BODY -> INSTRUCTION .)
    FOR             reduce using rule 37 (BODY -> INSTRUCTION .)
    PRINT           reduce using rule 37 (BODY -> INSTRUCTION .)
    BREAK           reduce using rule 37 (BODY -> INSTRUCTION .)
    CONTINUE        reduce using rule 37 (BODY -> INSTRUCTION .)
    RETURN          reduce using rule 37 (BODY -> INSTRUCTION .)
    ID              reduce using rule 37 (BODY -> INSTRUCTION .)
    $end            reduce using rule 37 (BODY -> INSTRUCTION .)
    }               reduce using rule 37 (BODY -> INSTRUCTION .)


state 92

    (35) CONDITION -> EXPRESSION COMPARISION_OPERATOR EXPRESSION .
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    )               reduce using rule 35 (CONDITION -> EXPRESSION COMPARISION_OPERATOR EXPRESSION .)
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 93

    (40) WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .

    IF              reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    WHILE           reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    FOR             reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    PRINT           reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    BREAK           reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    CONTINUE        reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    RETURN          reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    ID              reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    $end            reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    ELSE            reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)
    }               reduce using rule 40 (WHILE_STATEMENT -> WHILE ( CONDITION ) BODY .)


state 94

    (41) FOR_STATEMENT -> FOR ID = RANGE BODY .

    IF              reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    WHILE           reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    FOR             reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    PRINT           reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    BREAK           reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    CONTINUE        reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    RETURN          reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    ID              reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    $end            reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    ELSE            reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)
    }               reduce using rule 41 (FOR_STATEMENT -> FOR ID = RANGE BODY .)


state 95

    (42) RANGE -> EXPRESSION : . EXPRESSION
    (43) RANGE -> EXPRESSION : . EXPRESSION : EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    EXPRESSION                     shift and go to state 100
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 96

    (30) EXPRESSION -> FUNCTION ( EXPRESSION ) .

    '               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    +               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    -               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    *               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    /               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    M_PLUS          reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    M_MINUS         reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    M_TIMES         reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    M_DIVIDE        reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    ,               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    ;               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    <               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    >               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    EQ              reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    NEQ             reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    GE              reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    LE              reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    ]               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    )               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    :               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    {               reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    IF              reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    WHILE           reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    FOR             reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    PRINT           reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    BREAK           reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    CONTINUE        reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    RETURN          reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)
    ID              reduce using rule 30 (EXPRESSION -> FUNCTION ( EXPRESSION ) .)


state 97

    (23) ROWS -> ROWS ; SEQUENCE .
    (14) SEQUENCE -> SEQUENCE . , EXPRESSION

    ]               reduce using rule 23 (ROWS -> ROWS ; SEQUENCE .)
    ;               reduce using rule 23 (ROWS -> ROWS ; SEQUENCE .)
    ,               shift and go to state 55


state 98

    (39) IF_STATEMENT -> IF ( CONDITION ) BODY ELSE . BODY
    (36) BODY -> . { INSTRUCTIONS }
    (37) BODY -> . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . IF_STATEMENT
    (6) INSTRUCTION -> . WHILE_STATEMENT
    (7) INSTRUCTION -> . FOR_STATEMENT
    (8) STATEMENT -> . ASSIGNMENT
    (9) STATEMENT -> . KEYWORD
    (38) IF_STATEMENT -> . IF ( CONDITION ) BODY
    (39) IF_STATEMENT -> . IF ( CONDITION ) BODY ELSE BODY
    (40) WHILE_STATEMENT -> . WHILE ( CONDITION ) BODY
    (41) FOR_STATEMENT -> . FOR ID = RANGE BODY
    (10) ASSIGNMENT -> . LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION
    (31) KEYWORD -> . PRINT SEQUENCE
    (32) KEYWORD -> . BREAK
    (33) KEYWORD -> . CONTINUE
    (34) KEYWORD -> . RETURN EXPRESSION
    (11) LEFT_ASSIGNMENT -> . ID
    (12) LEFT_ASSIGNMENT -> . ACCESS
    (13) ACCESS -> . ID [ SEQUENCE ]

    {               shift and go to state 90
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    PRINT           shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    RETURN          shift and go to state 18
    ID              shift and go to state 13

    BODY                           shift and go to state 101
    INSTRUCTION                    shift and go to state 91
    STATEMENT                      shift and go to state 4
    IF_STATEMENT                   shift and go to state 5
    WHILE_STATEMENT                shift and go to state 6
    FOR_STATEMENT                  shift and go to state 7
    ASSIGNMENT                     shift and go to state 8
    KEYWORD                        shift and go to state 9
    LEFT_ASSIGNMENT                shift and go to state 14
    ACCESS                         shift and go to state 19

state 99

    (36) BODY -> { INSTRUCTIONS . }
    (2) INSTRUCTIONS -> INSTRUCTIONS . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . IF_STATEMENT
    (6) INSTRUCTION -> . WHILE_STATEMENT
    (7) INSTRUCTION -> . FOR_STATEMENT
    (8) STATEMENT -> . ASSIGNMENT
    (9) STATEMENT -> . KEYWORD
    (38) IF_STATEMENT -> . IF ( CONDITION ) BODY
    (39) IF_STATEMENT -> . IF ( CONDITION ) BODY ELSE BODY
    (40) WHILE_STATEMENT -> . WHILE ( CONDITION ) BODY
    (41) FOR_STATEMENT -> . FOR ID = RANGE BODY
    (10) ASSIGNMENT -> . LEFT_ASSIGNMENT ASSIGNMENT_OPERATOR EXPRESSION
    (31) KEYWORD -> . PRINT SEQUENCE
    (32) KEYWORD -> . BREAK
    (33) KEYWORD -> . CONTINUE
    (34) KEYWORD -> . RETURN EXPRESSION
    (11) LEFT_ASSIGNMENT -> . ID
    (12) LEFT_ASSIGNMENT -> . ACCESS
    (13) ACCESS -> . ID [ SEQUENCE ]

    }               shift and go to state 102
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    PRINT           shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    RETURN          shift and go to state 18
    ID              shift and go to state 13

    INSTRUCTION                    shift and go to state 20
    STATEMENT                      shift and go to state 4
    IF_STATEMENT                   shift and go to state 5
    WHILE_STATEMENT                shift and go to state 6
    FOR_STATEMENT                  shift and go to state 7
    ASSIGNMENT                     shift and go to state 8
    KEYWORD                        shift and go to state 9
    LEFT_ASSIGNMENT                shift and go to state 14
    ACCESS                         shift and go to state 19

state 100

    (42) RANGE -> EXPRESSION : EXPRESSION .
    (43) RANGE -> EXPRESSION : EXPRESSION . : EXPRESSION
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    {               reduce using rule 42 (RANGE -> EXPRESSION : EXPRESSION .)
    IF              reduce using rule 42 (RANGE -> EXPRESSION : EXPRESSION .)
    WHILE           reduce using rule 42 (RANGE -> EXPRESSION : EXPRESSION .)
    FOR             reduce using rule 42 (RANGE -> EXPRESSION : EXPRESSION .)
    PRINT           reduce using rule 42 (RANGE -> EXPRESSION : EXPRESSION .)
    BREAK           reduce using rule 42 (RANGE -> EXPRESSION : EXPRESSION .)
    CONTINUE        reduce using rule 42 (RANGE -> EXPRESSION : EXPRESSION .)
    RETURN          reduce using rule 42 (RANGE -> EXPRESSION : EXPRESSION .)
    ID              reduce using rule 42 (RANGE -> EXPRESSION : EXPRESSION .)
    :               shift and go to state 103
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57

state 101

    (39) IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .

    IF              reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    WHILE           reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    FOR             reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    PRINT           reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    BREAK           reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    CONTINUE        reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    RETURN          reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    ID              reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    $end            reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    ELSE            reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)
    }               reduce using rule 39 (IF_STATEMENT -> IF ( CONDITION ) BODY ELSE BODY .)


state 102

    (36) BODY -> { INSTRUCTIONS } .

    ELSE            reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    IF              reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    WHILE           reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    FOR             reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    PRINT           reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    BREAK           reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    CONTINUE        reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    RETURN          reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    ID              reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    $end            reduce using rule 36 (BODY -> { INSTRUCTIONS } .)
    }               reduce using rule 36 (BODY -> { INSTRUCTIONS } .)


state 103

    (43) RANGE -> EXPRESSION : EXPRESSION : . EXPRESSION
    (25) EXPRESSION -> . VALUE
    (26) EXPRESSION -> . - EXPRESSION
    (27) EXPRESSION -> . EXPRESSION '
    (28) EXPRESSION -> . ( EXPRESSION )
    (29) EXPRESSION -> . EXPRESSION MATHEMATICAL_OPERATOR EXPRESSION
    (30) EXPRESSION -> . FUNCTION ( EXPRESSION )
    (16) VALUE -> . FLOAT
    (17) VALUE -> . INT
    (18) VALUE -> . STRING
    (19) VALUE -> . ID
    (20) VALUE -> . MATRIX
    (21) VALUE -> . ACCESS
    (63) FUNCTION -> . EYE
    (64) FUNCTION -> . ZEROS
    (65) FUNCTION -> . ONES
    (22) MATRIX -> . [ ROWS ]
    (13) ACCESS -> . ID [ SEQUENCE ]

    -               shift and go to state 35
    (               shift and go to state 36
    FLOAT           shift and go to state 38
    INT             shift and go to state 39
    STRING          shift and go to state 40
    ID              shift and go to state 41
    EYE             shift and go to state 44
    ZEROS           shift and go to state 45
    ONES            shift and go to state 46
    [               shift and go to state 47

    EXPRESSION                     shift and go to state 104
    VALUE                          shift and go to state 34
    FUNCTION                       shift and go to state 37
    MATRIX                         shift and go to state 42
    ACCESS                         shift and go to state 43

state 104

    (43) RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .
    (27) EXPRESSION -> EXPRESSION . '
    (29) EXPRESSION -> EXPRESSION . MATHEMATICAL_OPERATOR EXPRESSION
    (55) MATHEMATICAL_OPERATOR -> . +
    (56) MATHEMATICAL_OPERATOR -> . -
    (57) MATHEMATICAL_OPERATOR -> . *
    (58) MATHEMATICAL_OPERATOR -> . /
    (59) MATHEMATICAL_OPERATOR -> . M_PLUS
    (60) MATHEMATICAL_OPERATOR -> . M_MINUS
    (61) MATHEMATICAL_OPERATOR -> . M_TIMES
    (62) MATHEMATICAL_OPERATOR -> . M_DIVIDE

    {               reduce using rule 43 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    IF              reduce using rule 43 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    WHILE           reduce using rule 43 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    FOR             reduce using rule 43 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    PRINT           reduce using rule 43 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    BREAK           reduce using rule 43 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    CONTINUE        reduce using rule 43 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    RETURN          reduce using rule 43 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    ID              reduce using rule 43 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    '               shift and go to state 56
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    M_PLUS          shift and go to state 62
    M_MINUS         shift and go to state 63
    M_TIMES         shift and go to state 64
    M_DIVIDE        shift and go to state 65

    MATHEMATICAL_OPERATOR          shift and go to state 57
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ' in state 84 resolved as shift
WARNING: shift/reduce conflict for + in state 84 resolved as shift
WARNING: shift/reduce conflict for - in state 84 resolved as shift
WARNING: shift/reduce conflict for * in state 84 resolved as shift
WARNING: shift/reduce conflict for / in state 84 resolved as shift
WARNING: shift/reduce conflict for M_PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for M_MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for M_TIMES in state 84 resolved as shift
WARNING: shift/reduce conflict for M_DIVIDE in state 84 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 89 resolved as shift
